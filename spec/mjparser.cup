

package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;
import rs.ac.bg.etf.pp1.ast.*;

parser code {:

	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }


:}


scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROG, NAMESPACE;
terminal IF, ELSE, BREAK, CONTINUE;
terminal FOR;
terminal PRINT, READ;
terminal STATIC, CONST;
terminal VOID, RETURN;
terminal PLUS, MINUS, MUL, DIV, MOD;
terminal EQ, NEQ, GT, GTE, LT, LTE;
terminal AND, OR;
terminal INC, DEC;
terminal COLON, DOT, SEMI, ASSIGN, COMMA;
terminal LSQUARE, RSQUARE, LPAREN, RPAREN, LBRACE, RBRACE;
terminal BOOLEAN, CHAR, NUMBER;
terminal IDENT;
terminal NEW;

nonterminal Program;
nonterminal NamespaceDeclList, ConstVarDeclList;
nonterminal Namespace;
nonterminal ConstDecl, VarDecl, MethodDecl;
nonterminal Type, MethodType;
nonterminal MethodVarDeclList;
nonterminal ConstTypeList;
nonterminal ConstDeclList, VarDeclList, MethodDeclList;
nonterminal FormPars, FormParsList;
nonterminal StatementList, Statement, Matched, Unmatched;
nonterminal Condition, Expr, CondTerm, CondFact, Term, Factor;
nonterminal Relop, Addop, Mulop, Assignop;
nonterminal DesignatorDecl, Designator, DesignatorList;
nonterminal ActPars, ActParsList;
nonterminal Label;
nonterminal DesignatorStatement, DesignatorStmtList;
nonterminal ForDesignatorStmtList, ForCondition;
nonterminal IfCondition;

Program ::= PROG IDENT NamespaceDeclList ConstVarDeclList LBRACE MethodDeclList RBRACE;

NamespaceDeclList ::= NamespaceDeclList Namespace
		           	|
		           	/* epsilon */
		           	;

Namespace ::= NAMESPACE IDENT LBRACE ConstVarDeclList LBRACE MethodDeclList RBRACE RBRACE;

ConstVarDeclList ::= ConstVarDeclList ConstDecl
				   |
				   ConstVarDeclList VarDecl
				   |
				   /* epsilon */
				   ; 
			
ConstDecl ::= CONST Type:constType IDENT:constName ASSIGN ConstTypeList ConstDeclList SEMI;

ConstTypeList ::= NUMBER | CHAR | BOOLEAN;

ConstDeclList ::= ConstDeclList COMMA IDENT:constName ASSIGN ConstTypeList
				|
				/* epsilon */
				;

Type ::= IDENT:typeName
	   |
	   IDENT:outerTypeName COLON COLON IDENT:innerTypeName
	   ;
	   
VarDecl ::= Type:varType IDENT:varName VarDeclList SEMI
    	  |
    	  Type:varArrayType IDENT:varArrayName LSQUARE RSQUARE VarDeclList SEMI
	  	  ;

VarDeclList ::= VarDeclList COMMA IDENT:varName
			  |
			  VarDeclList COMMA IDENT:varArrayName LSQUARE RSQUARE
			  |
			  /* epsilon */
			  ;
			  
MethodDeclList ::= MethodDeclList MethodDecl 
  				 |
  				 /* epsilon */
  				 ;
  				 
MethodDecl ::= MethodType IDENT LPAREN FormPars RPAREN MethodVarDeclList LBRACE StatementList RBRACE;

MethodVarDeclList ::= MethodVarDeclList VarDecl
				   |
				   /* epsilon */
				   ; 

MethodType ::= Type | VOID;

FormPars ::= Type:paramType IDENT:paramName FormParsList 
		   |
		   Type:paramArrayType IDENT:paramArrayName LSQUARE RSQUARE FormParsList
		   |
		   /* epsilon */
		   ;

FormParsList ::= FormParsList COMMA Type:paramType IDENT:paramName
			   |
			   FormParsList COMMA Type:paramArrayType IDENT:paramArrayName LSQUARE RSQUARE
			   |
			   /* epsilon */
			   ;
			   
StatementList ::= StatementList Statement
			    |
			    /* epsilon */
			    ;
			    
Statement ::= Matched
			|
			Unmatched
			;
			
Unmatched ::= IfCondition Statement
			|
			IfCondition Matched ELSE Unmatched
			|
			FOR LPAREN ForDesignatorStmtList SEMI ForCondition SEMI ForDesignatorStmtList RPAREN Unmatched
			;
			    
Matched ::= DesignatorStatement SEMI
			|
			IfCondition Matched ELSE Matched
			|
			BREAK SEMI
			|
			CONTINUE SEMI
			|
			RETURN Expr:returnExpr SEMI
			|
			RETURN SEMI
			|
			READ LPAREN Designator RPAREN SEMI
			|
			PRINT LPAREN Expr:e RPAREN SEMI
			|
			PRINT LPAREN Expr:e COMMA NUMBER RPAREN SEMI
			|
			FOR LPAREN ForDesignatorStmtList SEMI ForCondition SEMI ForDesignatorStmtList RPAREN Matched
			| 
			LBRACE StatementList RBRACE
			;
			
IfCondition ::= (IfCondition) IF LPAREN Condition RPAREN;
			
ForDesignatorStmtList ::= ForDesignatorStmtList COMMA DesignatorStatement
						 |
						 DesignatorStatement 
						 |
						 /* epsilon */
						 ;
			
ForCondition ::= CondFact
			   |
			   /* epsilon */
			   ;

Condition ::= Condition OR CondTerm 
			|
			CondTerm
			;
			   
CondTerm ::= CondTerm AND CondFact
		   |
		   CondFact
		   ;
		   
CondFact ::= Expr:exp
		   |
		   Expr:exp1 Relop Expr:exp2
		   ;
		   
Expr ::= Expr:texp Addop Term:t
	   |
	   Expr:texp Addop MINUS Term:t
	   |
	   Term:t
	   | 
	   MINUS Term:t
	   ;
	   
Term ::= Term:fterm Mulop Factor:f
	   |
	   Factor:f
	   ;
	   
Factor ::= DesignatorDecl 
		 | 
		 NUMBER
		 |
		 CHAR
	   	 |
	   	 BOOLEAN
	   	 |
	   	 NEW Type:factorType LSQUARE Expr:e RSQUARE
	   	 |
	   	 NEW Type:factorType LPAREN RPAREN
	   	 |
	   	 NEW Type:factorType LPAREN ActPars RPAREN
	   	 |
	   	 LPAREN Expr RPAREN
	   	 ;
	   	 
DesignatorDecl ::= Designator 
				 | 
				 Designator LPAREN RPAREN
				 |
				 Designator LPAREN ActPars RPAREN
	   	 		 ;
	   	 		 
Designator ::= IDENT:outerTypeName COLON COLON IDENT:innerName DesignatorList
			 |
			 IDENT:identName DesignatorList
			 ;
			 
DesignatorList ::= DesignatorList DOT IDENT:id
				 |
				 DesignatorList LSQUARE Expr:e RSQUARE
				 |
				 /* epsilon */
				 ;
				 
DesignatorStatement ::= Designator:d Assignop Expr:e
					  |
					  Designator:d LPAREN RPAREN
					  |
					  Designator:d LPAREN ActPars RPAREN
					  |
					  Designator:d INC
					  |
					  Designator:d DEC
					  |
					  LSQUARE DesignatorStmtList MUL Designator:d1 RSQUARE ASSIGN Designator:d2
					  ;
				 
DesignatorStmtList ::= DesignatorStmtList COMMA 
					 |
					 DesignatorStmtList Designator:d COMMA
					 |
					 /* epsilon */
					 ;
				 
ActPars ::= Expr:e ActParsList;

ActParsList ::= ActParsList COMMA Expr:e
			  | 
			  /* epsilon */
			  ;
				 
Label ::= IDENT:id;

Assignop ::= ASSIGN;
	   	 		 
Relop ::= EQ | NEQ | GT | GTE | LT | LTE;

Addop ::= PLUS | MINUS;

Mulop ::= MUL | DIV | MOD;